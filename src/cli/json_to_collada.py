"""CLI tool to convert JSON animation files to Collada format."""

from __future__ import annotations

import argparse
import json
import logging
from pathlib import Path
from typing import Dict, List, Any

import numpy as np
import torch

from src.features.dataset_builder.animation_rebuilder import AnimationRebuilder
from src.features.dataset_builder.config_loader import loadBuilderConfig
from src.shared.quaternion import Rotation
from src.shared.types import AnimationSample, DatasetBuilderConfig, DatasetBuildOptions

# Configure logging
logging.basicConfig(level=logging.INFO)
LOGGER = logging.getLogger("json_to_collada")


def buildArgumentParser() -> argparse.ArgumentParser:
    """
    Create the CLI argument parser.

    Returns
    -------
    argparse.ArgumentParser
        Configured parser instance.
    """
    parser = argparse.ArgumentParser(
        description="Convert a JSON animation file to Collada (.dae) format.",
    )
    parser.add_argument(
        "input_file",
        type=Path,
        help="Path to the input JSON animation file.",
    )
    parser.add_argument(
        "--output",
        "-o",
        type=Path,
        help="Path for the output .dae file. Defaults to input filename with .dae extension.",
    )
    return parser


def load_json_animation(file_path: Path) -> Dict[str, Any]:
    """Load the JSON animation file."""
    with open(file_path, "r") as f:
        return json.load(f)


def convert_json_to_sample(data: Dict[str, Any], file_path: Path) -> AnimationSample:
    """
    Convert JSON data to AnimationSample.
    
    The JSON is expected to have:
    - meta: { fps: number, ... }
    - bones: [ { name: str, frames: [ { rotation: [6 floats], ... }, ... ] }, ... ]
    
    We need to reconstruct the full axis-angle array (frames, bones, 3).
    AnimationRebuilder expects axisAngles in shape (frames, bones*3).
    """
    meta = data.get("meta", {})
    fps = int(meta.get("fps", 30))
    
    bones_data = data.get("bones", [])
    if not bones_data:
        raise ValueError("No bone data found in JSON.")

    # Determine number of frames
    num_frames = 0
    if bones_data:
        num_frames = len(bones_data[0].get("frames", []))
    
    # We need to map bone names to indices to reconstruct the ordered array
    # AnimationRebuilder uses SMPL24_BONE_ORDER as sourceBoneOrder by default in __init__
    # But here we are reconstructing FROM the "target" format (SMPL22) back to something AnimationRebuilder can process?
    # Wait, AnimationRebuilder.exportCollada takes an AnimationSample.
    # AnimationSample has .axisAngles.
    # AnimationRebuilder.exportCollada uses .axisAngles and assumes they are in sourceBoneOrder (SMPL24) if it uses self.boneIndex?
    # Let's check AnimationRebuilder.exportCollada implementation.
    
    # In exportCollada:
    # for bone_name in SMPL22_BONE_ORDER:
    #     source_index = self.boneIndex.get(bone_name)
    
    # self.boneIndex is built from self.sourceBoneOrder (SMPL24_BONE_ORDER).
    # So exportCollada expects the input sample.axisAngles to be ordered according to SMPL24.
    
    # However, our input JSON likely contains SMPL22 bones (as it was probably generated by this toolchain).
    # If the input JSON has "joints": "SMPL-22" in meta, it means we have SMPL22 bones.
    
    # We need to construct an array that matches SMPL24 order, filling in missing bones with identity?
    # Or does AnimationRebuilder handle this?
    
    # exportCollada iterates SMPL22_BONE_ORDER.
    # It looks up the bone name in self.boneIndex (SMPL24).
    # If found, it takes data from that index.
    
    # So we need to put our SMPL22 data into the correct slots of an SMPL24-sized array.
    
    from src.shared.constants.skeletons import SMPL24_BONE_ORDER
    
    smpl24_map = {name: i for i, name in enumerate(SMPL24_BONE_ORDER)}
    num_smpl24_bones = len(SMPL24_BONE_ORDER)
    
    # Initialize array with identity rotations (axis angle 0,0,0)
    # Shape: (frames, num_bones, 3)
    axis_angles_full = np.zeros((num_frames, num_smpl24_bones, 3), dtype=np.float32)
    
    for bone in bones_data:
        bone_name = bone.get("name")
        if bone_name not in smpl24_map:
            LOGGER.warning(f"Bone {bone_name} not found in SMPL24 skeleton, skipping.")
            continue
            
        target_idx = smpl24_map[bone_name]
        frames = bone.get("frames", [])
        
        # Extract rotations (assuming 6D from JSON)
        # JSON 6D: [r1, r2, r3, r4, r5, r6]
        rotations_6d = []
        for f in frames:
            rot = f.get("rotation")
            if rot and len(rot) == 6:
                rotations_6d.append(rot)
            else:
                rotations_6d.append([1.0, 0.0, 0.0, 0.0, 1.0, 0.0]) # Identity 6D? 
                # Identity matrix is [[1,0,0],[0,1,0],[0,0,1]]
                # 6D is first two columns: 1,0,0, 0,1,0 -> [1, 0, 0, 0, 1, 0]
        
        if not rotations_6d:
            continue
            
        rotations_6d_np = np.array(rotations_6d, dtype=np.float32) # (frames, 6)
        
        # Convert 6D to Axis-Angle
        # We can use our Rotation class
        rot_tensor = torch.from_numpy(rotations_6d_np)
        rot_obj = Rotation(rot_tensor, kind="rot6d")
        axis_angle = rot_obj.axis_angle.numpy() # (frames, 3)
        
        axis_angles_full[:, target_idx, :] = axis_angle

    # Flatten to (frames, bones*3) as expected by AnimationSample (usually)
    # But wait, AnimationRebuilder.loadSample produces:
    # axisAngles = raw["poses"].astype(np.float32)
    # AMASS poses are usually (frames, 156) or similar (52 bones * 3).
    
    axis_angles_flat = axis_angles_full.reshape(num_frames, -1)
    
    extras = data.get("extras", {})
    
    return AnimationSample(
        relativePath=file_path,
        resolvedPath=file_path.resolve(),
        axisAngles=axis_angles_flat,
        fps=fps,
        extras=extras,
    )


def main() -> None:
    """CLI entry-point."""
    parser = buildArgumentParser()
    args = parser.parse_args()
    
    input_path = args.input_file
    if not input_path.exists():
        parser.error(f"Input file not found: {input_path}")
        
    output_path = args.output
    if output_path is None:
        output_path = input_path.with_suffix(".dae")
        
    LOGGER.info(f"Loading {input_path}...")
    try:
        data = load_json_animation(input_path)
        sample = convert_json_to_sample(data, input_path)
        
        # We need a dummy config for AnimationRebuilder
        # It only uses config.paths.animationRoot in __init__, and config.processing.animationExtension in _animationCandidates
        # But we are bypassing loadSample, so we might get away with minimal config.
        # Actually __init__ resolves animationRoot.
        
        # Let's try to load the real config to be safe, or mock it.
        # Loading real config is better.
        config_path = Path("src/configs/dataset.yaml")
        if config_path.exists():
            config = loadBuilderConfig(config_path)
        else:
            # Fallback if running from weird location, though user seems to have it.
            # Mocking minimal config if needed.
            # For now assuming it exists as per user context.
            raise FileNotFoundError("Could not find src/configs/dataset.yaml")

        rebuilder = AnimationRebuilder(config)
        
        LOGGER.info(f"Exporting to {output_path}...")
        rebuilder.exportCollada(sample, output_path)
        LOGGER.info("Done.")
        
    except Exception as e:
        LOGGER.error(f"Conversion failed: {e}")
        exit(1)


if __name__ == "__main__":
    main()
